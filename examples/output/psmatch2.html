<!DOCTYPE html>
<html>
<head>
<title>Stata help for psmatch2</title>
<meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport">
<link href="css/smcl.css" type="text/css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Merriweather:900,400,400italic" type="text/css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:600,600italic" type="text/css" rel="stylesheet">
</head>
<body><div class="smcl">
<h1>Help for psmatch2</h1>
<hr>help for <strong>psmatch2</strong>
<hr margin_bottom="1">
<h2 margin_bottom="1">Mahalanobis and Propensity score Matching</h2>
<p class="8-21-2-0"><code class="command">psmatch2</code> <var class="command">depvar</var> [<var class="command">indepvars</var>] [<code class="command">if</code> <var class="command">exp</var>] [<code class="command">in</code> <var class="command">range</var>] [<code class="command">,</code> <code class="command"><u>out</u>come</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> <code class="command"><u>p</u>score</code><code class="command">(</code><var class="command">varname</var><code class="command">)</code> <code class="command"><u>n</u>eighbor</code><code class="command">(</code><var class="command">integer</var><code class="command">)</code> <code class="command">radius</code> <code class="command"><u>cal</u>iper</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command"><u>mahal</u>anobis</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> <code class="command">ai</code><code class="command">(</code><var class="command">integer</var><code class="command">)</code> <code class="command"><u>pop</u>ulation</code> <code class="command"><u>altv</u>ariance</code> <code class="command">kernel</code> <code class="command">llr</code> <code class="command"><u>k</u>erneltype</code><code class="command">(</code><var class="command">type</var><code class="command">)</code> <code class="command"><u>bw</u>idth</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command">spline</code> <code class="command"><u>n</u>knots</code><code class="command">(</code><var class="command">integer</var><code class="command">)</code> <code class="command"><u>com</u>mon</code> <code class="command">trim</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command"><u>norepl</u>acement</code> <code class="command"><u>desc</u>ending</code> <code class="command">odds</code> <code class="command">index</code> <code class="command">logit</code> <code class="command">ties</code> <code class="command"><u>qui</u>etly</code> <code class="command">w</code><code class="command">(</code><var class="command">matrix</var><code class="command">)</code> <code class="command">ate</code>] </p>
<p class="8-21-2-0">where <var class="command">indepvars</var> and <code class="command"><u>mahal</u>anobis</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> may contain factor variables; see <code class="command">fvvarlist</code>. </p>
<h2 margin_bottom="1">Description</h2>
<p class="std"><code class="command">psmatch2</code> implements full Mahalanobis matching and a variety of propensity score matching methods to adjust for pre-treatment observable differences between a group of treated and a group of untreated. Treatment status is identified by <var class="command">depvar</var>==1 for the treated and <var class="command">depvar</var>==0 for the untreated observations. </p>
<p class="std"><code class="command">psmatch2</code> is being continuously improved and developed. Make sure to keep your version up-to-date as follows </p>    <kbd> . ssc install psmatch2, replace</kbd>

<p class="std">By default <code class="command">psmatch2</code> calculates approximate standard errors on the treatment effects assuming independent observations, fixed weights, homoskedasticity of the outcome variable within the treated and within the control groups and that the variance of the outcome does not depend on the propensity score: </p>
<p class="std">1/N1*Var(Y | DM=1) + Sum(w_i^2; i in DM=0)/(N1)^2*Var(Y | DM=0) </p>
<p class="std">where N1 is the number of matched treated, DM=1 denotes the matched treated, DM=0 the matched controls and w_i is the weight given to control i. <code class="command">psmatch2</code> stores the estimate of the standard error of the ATT in <var class="command">r(seatt)</var> or with more than one outcome variable, in <var class="command">r(seatt_varname)</var>. </p>
<p class="std">With nearest neighbor matching on the X's (<code class="command">mahal()</code>), then analytical standard errors as in Abadie and Imbens (2006) are calculated when <var class="command">M&gt;0</var> is passed using option <code class="command">ai(</code><var class="command">M</var><code class="command">)</code>, where <var class="command">M</var> is the number of neighbors that are used to calculate the conditional variance (formula (14) in Abadie and Imbens, 2006). </p>
<p class="std"><code class="command">psmatch2</code> stores the estimate of the treatment effect on the treated in <var class="command">r(att)</var>, this allows bootstrapping of the standard error of the estimate (although it is unclear whether the bootstrap is valid in this context). This can be done as follows: </p>    <kbd> . bootstrap r(att) : psmatch2 training age gender, out(wage)</kbd>

<p class="std">If the average treatment is requested using option <var class="command">ate</var> the estimate is returned in <var class="command">r(ate)</var>. The average treatment effect on the untreated is then also returned in <var class="command">r(atu)</var>. With more than one outcome variable the effects are returned as r(att_<var class="command">varname</var>) etc. for each outcome variable and effect. </p>
<p class="std">See the documentation of <a class="command" href="http://www.stata.com/help.cgi?bootstrap"><b>bootstrap</b></a> for more details about bootstrapping in Stata. </p>
<p class="std">If you want to be able to replicate your results you should set <a class="command" href="http://www.stata.com/help.cgi?seed"><b>seed</b></a> before calling <code class="command">psmatch2</code>. </p>
<p class="std">The propensity score - the conditional treatment probability - is either directly provided by the user or estimated by the program on the <var class="command">indepvars</var>. Note that the sort order of your data could affect the results when using nearest-neighbor matching on a propensity score estimated with categorical (non-continuous) variables. Or more in general when there are untreated with identical propensity scores. </p>
<p class="std">Matching methods to choose from are one-to-one (nearest neighbour or within caliper; with or without replacement), <var class="command">k</var>-nearest neighbors, radius, kernel, local linear regression, 'spline-smoothing' and Mahalanobis matching. The following list presents the syntax for each method. </p>
<p class="std">You can also click <span options="psmatch2">{dialog psmatch2:here}</span> to pop up a <span options="psmatch2">{dialog psmatch2:dialog}</span> or type <kbd> db psmatch2</kbd>. </p>
<h2 margin_bottom="1">About sample weights</h2>
<p class="std">As far as we know it's not really clear in the literature how to accommodate sample weights in the context of matching. If you are aware how to properly account for sampling weights, please let us know. In the meantime, here are some thoughts you might want to take into consideration when asking yourself the following questions: </p>
<p class="std">1) Should I use weights when estimating the score? </p>
<p class="std">The recommendation to date seems to be to ignore sampling weights, estimate the propensity score using a logit model (option <code class="command">logit</code>) and match on the (logarithm of the) odds ratio (option <code class="command">odds</code>). </p>
<p class="std">2) Should I use weights after having performed matching? </p>
<p class="std">When interested in the effect of treatment on the treated, the sampling weights should refer to the treated alone. So the pweigths should be applied to the observed and to the matched outcome (if need be further restricted to the treated on the common support) for all the treated: </p>
<p class="std"><kbd> . sum outcome if treated==1 [aw=pweight]</kbd> </p>
<p class="std"><kbd> . sum _outcome if treated==1 [aw=pweight]</kbd> </p>
<h2 margin_bottom="1">Matching within strata</h2>
<p class="std">The following code illustrates how to match within exact cells and then calculate the average effect for the whole population. </p>	<code class="command">g att = .</code>
	<code class="command">egen g = group(groupvars)</code>
	<code class="command">levels g, local(gr)</code>
	<code class="command">qui foreach j of local gr <span options="-(">{c -(}</span></code>
		<code class="command">psmatch2 treatvar varlist if g==`j', out(outvar)</code>
		<code class="command">replace att = r(att) if  g==`j'</code>
	<code class="command"><span options=")-">{c )-}</span></code>
	<code class="command">sum att</code>

<h2 margin_bottom="1">Detailed Syntax</h2>
<p class="hang"><b>One-to-one matching:</b> </p>
<p class="8-21-2-0"><code class="command">psmatch2</code> <var class="command">depvar</var> [<var class="command">indepvars</var>] [<code class="command">if</code> <var class="command">exp</var>] [<code class="command">in</code> <var class="command">range</var>] <code class="command">,</code>     [<code class="command"><u>out</u>come</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> <code class="command"><u>p</u>score</code><code class="command">(</code><var class="command">varname</var><code class="command">)</code> <code class="command">ai</code><code class="command">(</code><var class="command">integer k</var>&gt;1<code class="command">)</code> <code class="command"><u>mahal</u>anobis</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> <code class="command"><u>cal</u>iper</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command"><u>norep</u>lacement</code> <code class="command"><u>desc</u>ending</code> <code class="command"><u>com</u>mon</code> <code class="command">trim</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command">odds</code> <code class="command">index</code> <code class="command">logit</code> <code class="command">ties</code> <code class="command"><u>nowarn</u>ings</code> <code class="command"><u>qui</u>etly</code> <code class="command">ate</code>] </p>
<p class="hang"><b><var class="command">k</var>-Nearest neighbors matching:</b> </p>
<p class="8-21-2-0"><code class="command">psmatch2</code> <var class="command">depvar</var> [<var class="command">indepvars</var>] [<code class="command">if</code> <var class="command">exp</var>] [<code class="command">in</code> <var class="command">range</var>] <code class="command">,</code>     [<code class="command"><u>out</u>come</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> <code class="command"><u>p</u>score</code><code class="command">(</code><var class="command">varname</var><code class="command">)</code> <code class="command"><u>n</u>eighbor</code><code class="command">(</code><var class="command">integer k</var>&gt;1<code class="command">)</code> <code class="command"><u>cal</u>iper</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command"><u>com</u>mon</code> <code class="command">trim</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command">odds</code> <code class="command">index</code> <code class="command">logit</code> <code class="command">ties</code> <code class="command"><u>nowarn</u>ings</code> <code class="command"><u>qui</u>etly</code> <code class="command">ate</code>] </p>
<p class="std"><b>Radius matching:</b> </p>
<p class="8-21-2-0"><code class="command">psmatch2</code> <var class="command">depvar</var> [<var class="command">indepvars</var>] [<code class="command">if</code> <var class="command">exp</var>] [<code class="command">in</code> <var class="command">range</var>] <code class="command">,</code> <code class="command">radius</code> <code class="command"><u>cal</u>iper</code><code class="command">(</code><var class="command">real</var><code class="command">)</code>     [<code class="command"><u>out</u>come</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> <code class="command"><u>p</u>score</code><code class="command">(</code><var class="command">varname</var><code class="command">)</code> <code class="command"><u>com</u>mon</code> <code class="command">trim</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command">odds</code> <code class="command">index</code> <code class="command">logit</code> <code class="command"><u>qui</u>etly</code> <code class="command">ate</code>] </p>
<p class="std"><b>Kernel matching:</b> </p>
<p class="8-21-2-0"><code class="command">psmatch2</code> <var class="command">depvar</var> [<var class="command">indepvars</var>] [<code class="command">if</code> <var class="command">exp</var>] [<code class="command">in</code> <var class="command">range</var>] <code class="command">,</code> <code class="command">kernel</code>     [<code class="command"><u>out</u>come</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> <code class="command"><u>k</u>erneltype</code><code class="command">(</code><var class="command">kernel_type</var><code class="command">)</code> <code class="command"><u>p</u>score</code><code class="command">(</code><var class="command">varname</var><code class="command">)</code> <code class="command"><u>bw</u>idth</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command"><u>mahal</u>anobis</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> <code class="command"><u>com</u>mon</code> <code class="command">trim</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command">odds</code> <code class="command">index</code> <code class="command">logit</code> <code class="command"><u>qui</u>etly</code> <code class="command">ate</code>] </p>
<p class="std"><b>Local linear regression matching:</b> </p>
<p class="8-21-2-0"><code class="command">psmatch2</code> <var class="command">depvar</var> [<var class="command">indepvars</var>] [<code class="command">if</code> <var class="command">exp</var>] [<code class="command">in</code> <var class="command">range</var>] <code class="command">,</code> <code class="command">llr</code> <code class="command"><u>out</u>come</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code>     [<code class="command"><u>k</u>erneltype</code><code class="command">(</code><var class="command">kernel_type</var><code class="command">)</code> <code class="command"><u>p</u>score</code><code class="command">(</code><var class="command">varname</var><code class="command">)</code> <code class="command"><u>bw</u>idth</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command"><u>mahal</u>anobis</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> <code class="command"><u>com</u>mon</code> <code class="command">trim</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command">odds</code> <code class="command">index</code> <code class="command">logit</code> <code class="command"><u>qui</u>etly</code> <code class="command">ate</code>] </p>
<p class="hang"><b>Spline matching:</b> </p>
<p class="8-21-2-0"><code class="command">psmatch2</code> <var class="command">depvar</var> [<var class="command">indepvars</var>] [<code class="command">if</code> <var class="command">exp</var>] [<code class="command">in</code> <var class="command">range</var>] <code class="command">,</code> <code class="command">spline</code> <code class="command"><u>out</u>come</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code>     [<code class="command"><u>nk</u>nots(</code><var class="command">integer</var><code class="command">)</code> <code class="command"><u>p</u>score</code><code class="command">(</code><var class="command">varname</var><code class="command">)</code> <code class="command"><u>n</u>eighbor</code><code class="command">(</code><var class="command">integer</var><code class="command">)</code> <code class="command"><u>cal</u>iper</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command"><u>com</u>mon</code> <code class="command">trim</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command">odds</code> <code class="command">index</code> <code class="command">logit</code> <code class="command">ties</code> <code class="command"><u>nowarn</u>ings</code> <code class="command"><u>qui</u>etly</code> <code class="command">ate</code>] </p>
<p class="std"><b>Mahalanobis matching:</b> </p>
<p class="8-21-2-0"><code class="command">psmatch2</code> <var class="command">depvar</var> [<code class="command">if</code> <var class="command">exp</var>] [<code class="command">in</code> <var class="command">range</var>] <code class="command">,</code> <code class="command"><u>mahal</u>anobis</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> <code class="command"><u>out</u>come</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> <code class="command">ai</code><code class="command">(</code><var class="command">integer</var><code class="command">)</code>     [<code class="command"><u>pop</u>ulation</code> <code class="command"><u>altv</u>ariance</code> <code class="command"><u>k</u>ernel</code><code class="command">(</code><var class="command">kernel_type</var><code class="command">)</code> <code class="command">llr</code> <code class="command"><u>bw</u>idth</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command"><u>cal</u>iper</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> <code class="command">w</code><code class="command">(</code><var class="command">matrix</var><code class="command">)</code> <code class="command">ate</code>] </p>
<p class="std"><code class="command">psmatch2</code> creates a number of variables for the convenience of the user: </p>
<p class="more"><kbd>_treated</kbd> is a variable that equals 0 for control observations and 1 for treatment observations. </p>
<p class="more"><kbd>_support</kbd> is an indicator variable with equals 1 if the observation is on the common support and 0 if the observatio is off the support. </p>
<p class="more"><kbd>_pscore</kbd> is the estimated propensity score or a copy of the one provided by <code class="command"><u>p</u>score()</code>. </p>
<p class="more"><kbd>_<var class="command">outcome_variable</var></kbd> for every treatment observation stores the value of the matched outcome. </p>
<p class="more"><kbd>_weight</kbd>. For nearest neighbor matching, it holds the frequency with which the observation is used as a match; with option <code class="command">ties</code> and k-nearest neighbors matching it holds the normalized weight; for kernel matching, and llr matching with a weight other than stata's tricube, it stores the overall weight given to the matched observation. When estimating att only _weight = 1 for the treated. </p>
<p class="more"><kbd>_id</kbd> In the case of one-to-one and nearest-neighbors matching, a new identifier created for all observations. </p>
<p class="more"><kbd>_n<var class="command">k</var></kbd> In the case of one-to-one and nearest-neighbors matching, for every treatment observation, it stores the observation number of the k-th matched control observation. Do not forget to sort by <var class="command">_id</var> if you want to use the observation number (id) of for example the 1st nearest neighbor as in </p>	<code class="command">sort _id</code>
	<code class="command">g x_of_match = x[_n1]</code>

<p class="more"><kbd>_nn</kbd> In the case of nearest-neighbors matching, for every treatment observation, it stores the number of matched control observations. </p>
<h2 margin_bottom="1">Options</h2>
<p class="hang"><code class="command"><u>out</u>come</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> the outcome variable(s). When evaluating multiple outcomes psmatch2 reduces to the min common number of observations with non-missing values on ALL outcomes, because otherwise the matching weigths will not sum to the right number. If you have multiple outcomes with widely differing missing values you may wish to run psmatch2 separately for each of the outcomes. </p>
<p class="hang"><code class="command">ate</code> with this option the average treatment effect (ate) and average treatment effect on the untreated (atu) are reported in addition to the average treatment effect on the treated (att). The estimates are returned in <var class="command">r(ate)</var>, <var class="command">r(atu)</var> and <var class="command">r(att)</var> respectively, see above. </p>
<p class="hang"><code class="command">ai</code><code class="command">(</code><var class="command">integer</var><code class="command">)</code> calculate the heteroskedasticity-consistent analytical standard errors proposed by Abadie and Imbens (2006) by specifying the number of neighbors to be used to calculate the conditional variance (their formula (14)). With option <code class="command"><u>altv</u>ariance</code> one can specify to use the estimator of Abadie et al. (2004) instead. </p>
<p class="more">Note that this is appropriate for nearest-neighbor matching on the X's, i.e. Mahalanobis-metric matching (<code class="command">mahal()</code>) not augmented with the propensity score. </p>
<p class="more">By default the sample variance is calculated (population variance can be calculated using option <code class="command"><u>pop</u>ulation</code>). </p>
<p class="hang"><code class="command"><u>pop</u>ulation</code> When using <code class="command">ai</code><code class="command">(</code><var class="command">integer</var><code class="command">)</code>, calculate the population variance rather than the sample variance (default). </p>
<p class="hang"><code class="command"><u>altv</u>ariance</code> When using <code class="command">ai</code><code class="command">(</code><var class="command">integer</var><code class="command">)</code>, calculate the conditional variance using the expression in Abadie et al. (2004, p.303). </p>
<h2 margin_bottom="1">Options: Estimation of the propensity score</h2>
<p class="hang"><code class="command"><u>p</u>score</code><code class="command">(</code><var class="command">varname</var><code class="command">)</code> specifies the variable to be used as propensity score. </p>
<p class="std">Alternatively, <var class="command">indepvars</var> need to be specified to allow the program to estimate the propensity score on them. In this case: </p>
<p class="hang"><code class="command">logit</code> use logit instead of the default probit to estimate the propensity score. </p>
<p class="hang"><code class="command"><u>qui</u>etly</code> do not print output of propensity score estimation. </p>
<p class="hang"><code class="command">odds</code> match on the logarithm of the odds ratio of the propensity score (stored in _pscore). </p>
<p class="hang"><code class="command">index</code> use the latent variable index instead of the probability. </p>
<p class="hang"><code class="command"><u>nowarn</u>ings</code> do not test for control observations with duplicate propensity score values. </p>
<h2 margin_bottom="1">Options: Imposition of common support</h2>
<p class="hang"><code class="command"><u>com</u>mon</code> imposes a common support by dropping treatment observations whose pscore is higher than the maximum or less than the minimum pscore of the controls. </p>
<p class="hang"><code class="command">trim(</code><var class="command">integer</var><code class="command">)</code> imposes common support by dropping # percent of the treatment observations at which the pscore density of the control observations is the lowest. </p>
<h2 margin_bottom="1">Options: Choice of matching estimator</h2>
<p class="hang"><code class="command"><u>n</u>eighbor</code><code class="command">(</code><var class="command">integer</var><code class="command">)</code> number of neighbors used to calculate the matched outcome. Defaults to 1. Default matching method is single nearest-neighbour (without caliper). </p>
<p class="hang"><code class="command"><u>norep</u>lacement</code> perform 1-to-1 matching without replacement. Nearest neigbor propensity score matching only. </p>
<p class="hang"><code class="command"><u>desc</u>ending</code> perform 1-to-1 matching without replacement in descending order. Nearest neighbor propensity score matching only. </p>
<p class="hang"><code class="command">ties</code> not only match nearest neighbor but also other controls with identical (tied) pscores. </p>
<p class="hang"><code class="command">radius</code> perform radius matching within the specified radius given by <code class="command">caliper</code>. </p>
<p class="hang"><code class="command"><u>cal</u>iper</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> value for maximum distance of controls. Use to perform nearest neighbor(s) within caliper, radius matching and Mahalanobis 1-to-1 matching. </p>
<p class="hang"><code class="command"><u>k</u>ernel</code> perform kernel matching. </p>
<p class="hang"><code class="command"><u>k</u>erneltype</code><code class="command">(</code><var class="command">kernel_type</var><code class="command">)</code> specifies the type of kernel: </p>
<p class="8-8-2-0"><kbd>normal</kbd> the gaussian kernel. </p>
<p class="8-8-2-0"><kbd>biweight</kbd> the biweight kernel. </p>
<p class="8-8-2-0"><kbd>epan</kbd> the epanechnikov kernel (Default). </p>
<p class="8-8-2-0"><kbd>uniform</kbd> the uniform kernel. </p>
<p class="8-8-2-0"><kbd>tricube</kbd> the tricube kernel. </p>
<p class="hang"><code class="command">llr</code> llr use local linear regression matching instead of kernel matching. </p>
<p class="hang"><code class="command"><u>bw</u>idth</code><code class="command">(</code><var class="command">real</var><code class="command">)</code> the bandwidth for kernel and local linear regression matching. Default bandwidth is 0.06, except when doing local linear regression with the Epanechnikov kernel when the default bandwidth is the rule-of-thumb bandwidth of <code class="command">lpoly</code>. </p>
<p class="hang"><code class="command"><u>mahal</u>anobis</code><code class="command">(</code><var class="command">varlist</var><code class="command">)</code> perform Mahalanobis-metric matching on <var class="command"> varlist</var>. </p>
<p class="hang"><code class="command">w</code><code class="command">(</code><var class="command">matrix</var><code class="command">)</code> specify alternative weighting matrix. Mahalanobis-metric matching becomes matching on a quadratic metric with the specified weighting matrix. </p>
<p class="hang"><code class="command">spline</code> performs 'spline-smoothing matching' by first fitting a natural cubic     spline on pscore (or on the result from estimate) to outcome.     The matched values are stored in the new variable, _s_outcomevar.  (It requires the <code class="command">spline</code> programme, which for stata7 needs to be downloaded by typing: net install snp7_1.) </p>
<p class="hang"><code class="command"><u>nk</u>nots(</code><var class="command">integer</var><code class="command">)</code> specifies the number of interior knots for spline smoothing. Default is     the fourth root of the number of comparison units. </p>
<h2 margin_bottom="1">Examples</h2>    <kbd> . psmatch2 training age gender, kernel k(biweight) out(wage)</kbd>
    <kbd> . psmatch2 training age gender, n(5) logit</kbd>
    <kbd> . psmatch2 training age gender, out(wage)</kbd>
    <kbd> . bs "psmatch2 training age gender, out(wage)" "r(att)"</kbd>

<h2 margin_bottom="1">Also see</h2>
<p class="std">The commands <a class="command" href="http://www.stata.com/help.cgi?pstest"><b>pstest</b></a>, <a class="command" href="http://www.stata.com/help.cgi?psgraph"><b>psgraph</b></a>. </p>
<h2 margin_bottom="1">Thanks for citing <code class="command">psmatch2</code> as follows</h2>
<p class="std">E. Leuven and B. Sianesi. (2003). "PSMATCH2: Stata module to perform full Mahalanobis and propensity score matching, common support graphing, and covariate imbalance testing". http://ideas.repec.org/c/boc/bocode/s432001.html. This version INSERT_VERSION_HERE. </p>where you can check your version as follows:
    <kbd> . which psmatch2</kbd>


<h2 margin_bottom="1">Disclaimer</h2>
<p class="std">THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. </p>
<p class="std">IN NO EVENT WILL THE COPYRIGHT HOLDERS OR THEIR EMPLOYERS, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THIS SOFTWARE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. </p>
<h2 margin_bottom="1">Background Reading</h2>
<p class="0-2-0-0">Abadie, A., Drukker, D., Herr, J. L., &amp; Imbens, G. W. (2004). "Implementing matching estimators for average treatment effects in Stata", <var class="command">Stata journal 4</var>, 290-311. </p>
<p class="0-2-0-0">Abadie A. and Imbens, G. (2006), "Large sample properties of matching estimators for average treatment effects", <var class="command">Econometrica 74</var>(1), 235-267. </p>
<p class="0-2-0-0">Cochran, W. and Rubin, D.B. (1973), "Controlling Bias in Observational Studies", <var class="command">Sankyha 35</var>, 417-446. </p>
<p class="0-2-0-0">Dehejia, R.H and Wahba, S. (1999), "Causal Effects in Non-Experimental Studies: Re-Evaluating the Evaluation of Training Programmes", <var class="command">Journal of the American Statistical Association 94</var>, 1053-1062. </p>
<p class="0-2-0-0">Heckman, J.J., Ichimura, H. and Todd, P.E. (1997), "Matching As An Econometric Evaluation Estimator: Evidence from Evaluating a Job Training Programme", <var class="command">Review of Economic Studies 64</var>, 605-654. </p>
<p class="0-2-0-0">Heckman, J.J., Ichimura, H. and Todd, P.E. (1998), "Matching as an Econometric Evaluation Estimator", <var class="command">Review of Economic Studies 65</var>, 261-294. </p>
<p class="0-2-0-0">Heckman, J.J., Ichimura, H., Smith, J.A. and Todd, P. (1998), "Characterising Selection Bias Using Experimental Data", <var class="command">Econometrica 66</var>, 5. </p>
<p class="0-2-0-0">Heckman, J.J., LaLonde, R.J., Smith, J.A. (1998), "The Economics and Econometrics of Active Labour Market Programmes", in Ashenfelter, O. and Card, D. (eds.), <var class="command">The Handbook of Labour Economics Vol. 3A</var>. </p>
<p class="0-2-0-0">Imbens, G. (2000), "The Role of Propensity Score in Estimating Dose-Response Functions", <var class="command">Biometrika 87(3)</var>, 706-710. </p>
<p class="0-2-0-0">Lechner, M. (2001), Identification and Estimation of Causal Effects of Multiple Treatments under the Conditional Independence Assumption, in: Lechner, M., Pfeiffer, F. (eds), <var class="command">Econometric Evaluation of Labour Market Policies</var>, Heidelberg: Physica/Springer, p. 43-58. </p>
<p class="0-2-0-0">Rosenbaum, P.R. and Rubin, D.B. (1983), "The Central Role of the Propensity Score in Observational Studies for Causal Effects", <var class="command">Biometrika 70</var>, 1, 41-55. </p>
<p class="0-2-0-0">Rosenbaum, P.R. and Rubin, D.B. (1985), "Constructing a Control Group Using Multivariate Matched Sampling Methods that Incorporate the Propensity Score", <var class="command">The American Statistician 39(1)</var>, 33-38. </p>
<p class="0-2-0-0">Rubin, D.B. (1974), "Estimating Causal Effects of Treatments in Randomised and Non-Randomised Studies", <var class="command">Journal of Educational Psychology 66</var>, 688-701. </p>
<p class="0-2-0-0">Rubin, D.B. (1980), "Bias Reduction Using Mahalanobis-Metric Matching", <var class="command">Biometrics 36</var>, 293-298. </p>
<h2 margin_bottom="1">Author</h2>
<p class="std">Edwin Leuven, University of Oslo. If you observe any problems <a class="command" href="mailto:e.leuven@gmail.com"><b>"mailto:e.leuven@gmail.com"</b></a>. </p>
<p class="std">Barbara Sianesi, Institute for Fiscal Studies, London, UK. </p>
</div></body>
</html>
